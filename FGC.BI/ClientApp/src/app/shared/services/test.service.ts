/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken('API_BASE_URL');

@Injectable()
export class ProductClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44384";
    }

    getProducts(): Observable<Product[]> {
        let url_ = this.baseUrl + "/api/Product";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<Product[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<Product[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product[]>(<any>null);
    }
}

@Injectable()
export class ProfileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44384";
    }

    profile(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processProfile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable()
export class PurchaseOrderDetailClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44384";
    }

    getData(startValue: Date | undefined, endValue: Date | undefined, pageIndex: number | undefined, pageSize: number | undefined): Observable<Result[]> {
        let url_ = this.baseUrl + "/api/PurchaseOrderDetail?";
        if (startValue === null)
            throw new Error("The parameter 'startValue' cannot be null.");
        else if (startValue !== undefined)
            url_ += "startValue=" + encodeURIComponent(startValue ? "" + startValue.toJSON() : "") + "&";
        if (endValue === null)
            throw new Error("The parameter 'endValue' cannot be null.");
        else if (endValue !== undefined)
            url_ += "endValue=" + encodeURIComponent(endValue ? "" + endValue.toJSON() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(<any>response_);
                } catch (e) {
                    return <Observable<Result[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<Result[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Result.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result[]>(<any>null);
    }

    getId(startValue: Date | undefined, endValue: Date | undefined, id: number | undefined): Observable<Result[]> {
        let url_ = this.baseUrl + "/api/PurchaseOrderDetail/product?";
        if (startValue === null)
            throw new Error("The parameter 'startValue' cannot be null.");
        else if (startValue !== undefined)
            url_ += "startValue=" + encodeURIComponent(startValue ? "" + startValue.toJSON() : "") + "&";
        if (endValue === null)
            throw new Error("The parameter 'endValue' cannot be null.");
        else if (endValue !== undefined)
            url_ += "endValue=" + encodeURIComponent(endValue ? "" + endValue.toJSON() : "") + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetId(<any>response_);
                } catch (e) {
                    return <Observable<Result[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Result[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetId(response: HttpResponseBase): Observable<Result[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Result.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result[]>(<any>null);
    }
}

export class Product implements IProduct {
    productID!: number;
    name?: string | undefined;
    productNumber?: string | undefined;
    makeFlag?: string | undefined;
    finishedGoodsFlag?: string | undefined;
    color?: string | undefined;
    safetyStockLevel!: number;
    reorderPoint!: number;
    standardCost!: number;
    listPrice!: number;
    size?: string | undefined;
    sizeUnitMeasureCode?: string | undefined;
    weightUnitMeasureCode?: string | undefined;
    weight!: number;
    daysToManufacture!: number;
    productLine?: string | undefined;
    class?: string | undefined;
    style?: string | undefined;
    productSubcategoryID!: number;
    productModelID!: number;
    sellStartDate!: Date;
    sellEndDate!: Date;
    discontinuedDate!: Date;
    rowguid?: string | undefined;
    modifiedDate!: Date;
    purchaseOrderDetails?: PurchaseOrderDetail[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productID = _data["productID"];
            this.name = _data["name"];
            this.productNumber = _data["productNumber"];
            this.makeFlag = _data["makeFlag"];
            this.finishedGoodsFlag = _data["finishedGoodsFlag"];
            this.color = _data["color"];
            this.safetyStockLevel = _data["safetyStockLevel"];
            this.reorderPoint = _data["reorderPoint"];
            this.standardCost = _data["standardCost"];
            this.listPrice = _data["listPrice"];
            this.size = _data["size"];
            this.sizeUnitMeasureCode = _data["sizeUnitMeasureCode"];
            this.weightUnitMeasureCode = _data["weightUnitMeasureCode"];
            this.weight = _data["weight"];
            this.daysToManufacture = _data["daysToManufacture"];
            this.productLine = _data["productLine"];
            this.class = _data["class"];
            this.style = _data["style"];
            this.productSubcategoryID = _data["productSubcategoryID"];
            this.productModelID = _data["productModelID"];
            this.sellStartDate = _data["sellStartDate"] ? new Date(_data["sellStartDate"].toString()) : <any>undefined;
            this.sellEndDate = _data["sellEndDate"] ? new Date(_data["sellEndDate"].toString()) : <any>undefined;
            this.discontinuedDate = _data["discontinuedDate"] ? new Date(_data["discontinuedDate"].toString()) : <any>undefined;
            this.rowguid = _data["rowguid"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["purchaseOrderDetails"])) {
                this.purchaseOrderDetails = [] as any;
                for (let item of _data["purchaseOrderDetails"])
                    this.purchaseOrderDetails!.push(PurchaseOrderDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productID"] = this.productID;
        data["name"] = this.name;
        data["productNumber"] = this.productNumber;
        data["makeFlag"] = this.makeFlag;
        data["finishedGoodsFlag"] = this.finishedGoodsFlag;
        data["color"] = this.color;
        data["safetyStockLevel"] = this.safetyStockLevel;
        data["reorderPoint"] = this.reorderPoint;
        data["standardCost"] = this.standardCost;
        data["listPrice"] = this.listPrice;
        data["size"] = this.size;
        data["sizeUnitMeasureCode"] = this.sizeUnitMeasureCode;
        data["weightUnitMeasureCode"] = this.weightUnitMeasureCode;
        data["weight"] = this.weight;
        data["daysToManufacture"] = this.daysToManufacture;
        data["productLine"] = this.productLine;
        data["class"] = this.class;
        data["style"] = this.style;
        data["productSubcategoryID"] = this.productSubcategoryID;
        data["productModelID"] = this.productModelID;
        data["sellStartDate"] = this.sellStartDate ? this.sellStartDate.toISOString() : <any>undefined;
        data["sellEndDate"] = this.sellEndDate ? this.sellEndDate.toISOString() : <any>undefined;
        data["discontinuedDate"] = this.discontinuedDate ? this.discontinuedDate.toISOString() : <any>undefined;
        data["rowguid"] = this.rowguid;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        if (Array.isArray(this.purchaseOrderDetails)) {
            data["purchaseOrderDetails"] = [];
            for (let item of this.purchaseOrderDetails)
                data["purchaseOrderDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProduct {
    productID: number;
    name?: string | undefined;
    productNumber?: string | undefined;
    makeFlag?: string | undefined;
    finishedGoodsFlag?: string | undefined;
    color?: string | undefined;
    safetyStockLevel: number;
    reorderPoint: number;
    standardCost: number;
    listPrice: number;
    size?: string | undefined;
    sizeUnitMeasureCode?: string | undefined;
    weightUnitMeasureCode?: string | undefined;
    weight: number;
    daysToManufacture: number;
    productLine?: string | undefined;
    class?: string | undefined;
    style?: string | undefined;
    productSubcategoryID: number;
    productModelID: number;
    sellStartDate: Date;
    sellEndDate: Date;
    discontinuedDate: Date;
    rowguid?: string | undefined;
    modifiedDate: Date;
    purchaseOrderDetails?: PurchaseOrderDetail[] | undefined;
}

export class PurchaseOrderDetail implements IPurchaseOrderDetail {
    purchaseOrderID!: number;
    purchaseOrderDetailID!: number;
    dueDate!: Date;
    orderQty!: number;
    productID!: number;
    unitPrice!: number;
    lineTotal!: number;
    receivedQty!: number;
    rejectedQty!: number;
    stockedQty!: number;
    modifiedDate!: Date;
    product?: Product | undefined;
    purchaseOrderHeader?: PurchaseOrderHeader | undefined;

    constructor(data?: IPurchaseOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderID = _data["purchaseOrderID"];
            this.purchaseOrderDetailID = _data["purchaseOrderDetailID"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.orderQty = _data["orderQty"];
            this.productID = _data["productID"];
            this.unitPrice = _data["unitPrice"];
            this.lineTotal = _data["lineTotal"];
            this.receivedQty = _data["receivedQty"];
            this.rejectedQty = _data["rejectedQty"];
            this.stockedQty = _data["stockedQty"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.purchaseOrderHeader = _data["purchaseOrderHeader"] ? PurchaseOrderHeader.fromJS(_data["purchaseOrderHeader"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PurchaseOrderDetail {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderID"] = this.purchaseOrderID;
        data["purchaseOrderDetailID"] = this.purchaseOrderDetailID;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["orderQty"] = this.orderQty;
        data["productID"] = this.productID;
        data["unitPrice"] = this.unitPrice;
        data["lineTotal"] = this.lineTotal;
        data["receivedQty"] = this.receivedQty;
        data["rejectedQty"] = this.rejectedQty;
        data["stockedQty"] = this.stockedQty;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["purchaseOrderHeader"] = this.purchaseOrderHeader ? this.purchaseOrderHeader.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPurchaseOrderDetail {
    purchaseOrderID: number;
    purchaseOrderDetailID: number;
    dueDate: Date;
    orderQty: number;
    productID: number;
    unitPrice: number;
    lineTotal: number;
    receivedQty: number;
    rejectedQty: number;
    stockedQty: number;
    modifiedDate: Date;
    product?: Product | undefined;
    purchaseOrderHeader?: PurchaseOrderHeader | undefined;
}

export class PurchaseOrderHeader implements IPurchaseOrderHeader {
    purchaseOrderHeaderID!: number;
    revisionNumber!: number;
    status!: number;
    employeeID!: number;
    vendorID!: number;
    shipMethodID!: number;
    orderDate!: Date;
    shipDate!: Date;
    subTotal!: number;
    taxAmt!: number;
    freight!: number;
    totalDue!: number;
    modifiedDate!: Date;
    purchaseOrderDetails?: PurchaseOrderDetail[] | undefined;

    constructor(data?: IPurchaseOrderHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderHeaderID = _data["purchaseOrderHeaderID"];
            this.revisionNumber = _data["revisionNumber"];
            this.status = _data["status"];
            this.employeeID = _data["employeeID"];
            this.vendorID = _data["vendorID"];
            this.shipMethodID = _data["shipMethodID"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.shipDate = _data["shipDate"] ? new Date(_data["shipDate"].toString()) : <any>undefined;
            this.subTotal = _data["subTotal"];
            this.taxAmt = _data["taxAmt"];
            this.freight = _data["freight"];
            this.totalDue = _data["totalDue"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["purchaseOrderDetails"])) {
                this.purchaseOrderDetails = [] as any;
                for (let item of _data["purchaseOrderDetails"])
                    this.purchaseOrderDetails!.push(PurchaseOrderDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseOrderHeader {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderHeaderID"] = this.purchaseOrderHeaderID;
        data["revisionNumber"] = this.revisionNumber;
        data["status"] = this.status;
        data["employeeID"] = this.employeeID;
        data["vendorID"] = this.vendorID;
        data["shipMethodID"] = this.shipMethodID;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["shipDate"] = this.shipDate ? this.shipDate.toISOString() : <any>undefined;
        data["subTotal"] = this.subTotal;
        data["taxAmt"] = this.taxAmt;
        data["freight"] = this.freight;
        data["totalDue"] = this.totalDue;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        if (Array.isArray(this.purchaseOrderDetails)) {
            data["purchaseOrderDetails"] = [];
            for (let item of this.purchaseOrderDetails)
                data["purchaseOrderDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPurchaseOrderHeader {
    purchaseOrderHeaderID: number;
    revisionNumber: number;
    status: number;
    employeeID: number;
    vendorID: number;
    shipMethodID: number;
    orderDate: Date;
    shipDate: Date;
    subTotal: number;
    taxAmt: number;
    freight: number;
    totalDue: number;
    modifiedDate: Date;
    purchaseOrderDetails?: PurchaseOrderDetail[] | undefined;
}

export class Result implements IResult {
    productName?: string | undefined;
    productNumber?: string | undefined;
    safetyStockLevel!: number;
    reorderPoint!: number;
    productID!: number;
    purchaseOrderDetailID!: number;
    purchaseOrderID!: number;
    dueDate!: Date;
    receivedQty!: number;
    month!: number;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
            this.productNumber = _data["productNumber"];
            this.safetyStockLevel = _data["safetyStockLevel"];
            this.reorderPoint = _data["reorderPoint"];
            this.productID = _data["productID"];
            this.purchaseOrderDetailID = _data["purchaseOrderDetailID"];
            this.purchaseOrderID = _data["purchaseOrderID"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.receivedQty = _data["receivedQty"];
            this.month = _data["month"];
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["productNumber"] = this.productNumber;
        data["safetyStockLevel"] = this.safetyStockLevel;
        data["reorderPoint"] = this.reorderPoint;
        data["productID"] = this.productID;
        data["purchaseOrderDetailID"] = this.purchaseOrderDetailID;
        data["purchaseOrderID"] = this.purchaseOrderID;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["receivedQty"] = this.receivedQty;
        data["month"] = this.month;
        return data; 
    }
}

export interface IResult {
    productName?: string | undefined;
    productNumber?: string | undefined;
    safetyStockLevel: number;
    reorderPoint: number;
    productID: number;
    purchaseOrderDetailID: number;
    purchaseOrderID: number;
    dueDate: Date;
    receivedQty: number;
    month: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}